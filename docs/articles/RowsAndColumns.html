<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Coordinatized Data: A Fluid Data Specification • cdata</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">cdata</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="..//index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/RowsAndColumns.html">Coordinatized Data: A Fluid Data Specification</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="http://www.win-vector.com/">Sponsor: Win-Vector LLC</a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>Coordinatized Data: A Fluid Data Specification</h1>
                        <h4 class="author">John Mount and Nina Zumel</h4>
            
            <h4 class="date">2017-08-01</h4>
          </div>

    
    
<div class="contents">
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>It has been our experience when teaching the data wrangling part of data science that students often have difficulty understanding the conversion to and from row-oriented and column-oriented data formats (what is commonly called pivoting and un-pivoting).</p>
<div class="figure">
<img src="wireLoom.png">
</div>
<p><a href="http://www.darkroastedblend.com/2014/01/machines-alive-whimsical-art-of-boris.html">Boris Artzybasheff illustration</a></p>
<p>Real trust and understanding of this concept doesn’t fully form until one realizes that rows and columns are <em>inessential</em> implementation details when <em>reasoning</em> about your data. Many <em>algorithms</em> are sensitive to how data is arranged in rows and columns, so there is a need to convert between representations. However, confusing representation with semantics slows down understanding.</p>
<p>In this article we will try to separate representation from semantics. We will advocate for thinking in terms of <em>coordinatized data</em>, and demonstrate advanced data wrangling in <a href="https://cran.r-project.org"><code>R</code></a>.</p>
</div>
<div id="example" class="section level2">
<h2 class="hasAnchor">
<a href="#example" class="anchor"></a>Example</h2>
<p>Consider four data scientists who perform the same set of modeling tasks, but happen to record the data differently.</p>
<p>In each case the data scientist was asked to test two decision tree regression models (<em>a</em> and <em>b</em>) on two test-sets (<em>x</em> and <em>y</em>) and record both the model quality on the test sets under two different metrics (<a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve"><code>AUC</code></a> and <a href="http://www.win-vector.com/blog/2011/09/the-simpler-derivation-of-logistic-regression/"><code>pseudo R-squared</code></a>). The two models differ in tree depth (in this case model <em>a</em> has depth 5, and model <em>b</em> has depth 3), which is also to be recorded.</p>
<div id="data-scientist-1" class="section level4">
<h4 class="hasAnchor">
<a href="#data-scientist-1" class="anchor"></a>Data Scientist 1</h4>
<div class="figure">
<img src="ML.png">
</div>
<p>Data scientist 1 is an experienced modeler, and records their data as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"tibble"</span>)
d1 &lt;-<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/tibble/topics/tribble">tribble</a></span>(
  ~model, ~depth, ~testset, ~AUC, ~pR2,
  <span class="st">'a'</span>,    <span class="dv">5</span>,      <span class="st">'x'</span>,      <span class="fl">0.4</span>,  <span class="fl">0.2</span>,
  <span class="st">'a'</span>,    <span class="dv">5</span>,      <span class="st">'y'</span>,      <span class="fl">0.6</span>,  <span class="fl">0.3</span>,
  <span class="st">'b'</span>,    <span class="dv">3</span>,      <span class="st">'x'</span>,      <span class="fl">0.5</span>,  <span class="fl">0.25</span>,
  <span class="st">'b'</span>,    <span class="dv">3</span>,      <span class="st">'y'</span>,      <span class="fl">0.5</span>,  <span class="fl">0.25</span>
)
<span class="kw">print</span>(d1)</code></pre></div>
<pre><code>## # A tibble: 4 x 5
##   model depth testset   AUC   pR2
##   &lt;chr&gt; &lt;dbl&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     a     5       x   0.4  0.20
## 2     a     5       y   0.6  0.30
## 3     b     3       x   0.5  0.25
## 4     b     3       y   0.5  0.25</code></pre>
<p>Data Scientist 1 uses what is called a <em>denormalized form</em>. In this form each row contains all of the facts we want ready to go. If we were thinking about “column roles” (a concept we touched on briefly in Section A.3.5 “How to Think in SQL” of <a href="http://www.practicaldatascience.com/"><em>Practical Data Science with R</em>, Zumel, Mount; Manning 2014</a>), then we would say the columns <code>model</code> and <code>testset</code> are <em>key columns</em> (together they form a <em>composite key</em> that uniquely identifies rows), the <code>depth</code> column is derived (it is a function of <code>model</code>), and <code>AUC</code> and <code>pR2</code> are <em>payload columns</em> (they contain data).</p>
<p>Denormalized forms are the most ready for tasks that reason across columns, such as training or evaluating machine learning models.</p>
</div>
<div id="data-scientist-2" class="section level4">
<h4 class="hasAnchor">
<a href="#data-scientist-2" class="anchor"></a>Data Scientist 2</h4>
<div class="figure">
<img src="DW.png">
</div>
<p>Data Scientist 2 has data warehousing experience and records their data in a <a href="https://en.wikipedia.org/wiki/Database_normalization#Normal_forms">normal form</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">models2 &lt;-<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/tibble/topics/tribble">tribble</a></span>(
  ~model, ~depth,
  <span class="st">'a'</span>,    <span class="dv">5</span>,
  <span class="st">'b'</span>,    <span class="dv">3</span>
)

d2 &lt;-<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/tibble/topics/tribble">tribble</a></span>(
  ~model, ~testset, ~AUC, ~pR2,
  <span class="st">'a'</span>,   <span class="st">'x'</span>,      <span class="fl">0.4</span>,  <span class="fl">0.2</span>,
  <span class="st">'a'</span>,   <span class="st">'y'</span>,      <span class="fl">0.6</span>,  <span class="fl">0.3</span>,
  <span class="st">'b'</span>,   <span class="st">'x'</span>,      <span class="fl">0.5</span>,  <span class="fl">0.25</span>,
  <span class="st">'b'</span>,   <span class="st">'y'</span>,      <span class="fl">0.5</span>,  <span class="fl">0.25</span>
)

<span class="kw">print</span>(models2)</code></pre></div>
<pre><code>## # A tibble: 2 x 2
##   model depth
##   &lt;chr&gt; &lt;dbl&gt;
## 1     a     5
## 2     b     3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(d2)</code></pre></div>
<pre><code>## # A tibble: 4 x 4
##   model testset   AUC   pR2
##   &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     a       x   0.4  0.20
## 2     a       y   0.6  0.30
## 3     b       x   0.5  0.25
## 4     b       y   0.5  0.25</code></pre>
<p>The idea is: since <code>depth</code> is a function of the model name, it should not be recorded as a column unless needed. In a normal form such as above, every item of data is written only one place. This means that we cannot have inconsistencies such as accidentally entering two different depths for a given model. In this example all our columns are either key or payload.</p>
<p>Data Scientist 2 is not concerned about any difficulty that might arise by this format as they know they can convert to Data Scientist 1’s format by using a <code>join</code> command:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">suppressPackageStartupMessages</span>(<span class="kw">library</span>(<span class="st">"dplyr"</span>))

d1_2 &lt;-<span class="st"> </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/join.html">left_join</a></span>(d2, models2, <span class="dt">by=</span><span class="st">'model'</span>) %&gt;%
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/select.html">select</a></span>(model, depth, testset, AUC, pR2) %&gt;%
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/arrange.html">arrange</a></span>(model, testset)
<span class="kw">print</span>(d1_2)</code></pre></div>
<pre><code>## # A tibble: 4 x 5
##   model depth testset   AUC   pR2
##   &lt;chr&gt; &lt;dbl&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     a     5       x   0.4  0.20
## 2     a     5       y   0.6  0.30
## 3     b     3       x   0.5  0.25
## 4     b     3       y   0.5  0.25</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">all.equal</span>(d1, d1_2)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p><a href="https://en.wikipedia.org/wiki/Relational_algebra">Relational</a> data theory (the science of joins) is the basis of Structured Query Language (<code>SQL</code>) and a topic any data scientist <em>must</em> master.</p>
</div>
<div id="data-scientist-3" class="section level4">
<h4 class="hasAnchor">
<a href="#data-scientist-3" class="anchor"></a>Data Scientist 3</h4>
<div class="figure">
<img src="SC.png">
</div>
<p>Data Scientist 3 has a lot of field experience, and prefers an <a href="https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model">entity/attribute/value</a> notation. They log each measurement as a separate row:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d3 &lt;-<span class="st"> </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/reexports.html">tribble</a></span>(
  ~model, ~depth, ~testset, ~measurement, ~value,
  <span class="st">'a'</span>,    <span class="dv">5</span>,      <span class="st">'x'</span>,      <span class="st">'AUC'</span>,        <span class="fl">0.4</span>,
  <span class="st">'a'</span>,    <span class="dv">5</span>,      <span class="st">'x'</span>,      <span class="st">'pR2'</span>,        <span class="fl">0.2</span>,
  <span class="st">'a'</span>,    <span class="dv">5</span>,      <span class="st">'y'</span>,      <span class="st">'AUC'</span>,        <span class="fl">0.6</span>,
  <span class="st">'a'</span>,    <span class="dv">5</span>,      <span class="st">'y'</span>,      <span class="st">'pR2'</span>,        <span class="fl">0.3</span>,
  <span class="st">'b'</span>,    <span class="dv">3</span>,      <span class="st">'x'</span>,      <span class="st">'AUC'</span>,        <span class="fl">0.5</span>,
  <span class="st">'b'</span>,    <span class="dv">3</span>,      <span class="st">'x'</span>,      <span class="st">'pR2'</span>,        <span class="fl">0.25</span>,
  <span class="st">'b'</span>,    <span class="dv">3</span>,      <span class="st">'y'</span>,      <span class="st">'AUC'</span>,        <span class="fl">0.5</span>,
  <span class="st">'b'</span>,    <span class="dv">3</span>,      <span class="st">'y'</span>,      <span class="st">'pR2'</span>,        <span class="fl">0.25</span>
)
<span class="kw">print</span>(d3)</code></pre></div>
<pre><code>## # A tibble: 8 x 5
##   model depth testset measurement value
##   &lt;chr&gt; &lt;dbl&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;dbl&gt;
## 1     a     5       x         AUC  0.40
## 2     a     5       x         pR2  0.20
## 3     a     5       y         AUC  0.60
## 4     a     5       y         pR2  0.30
## 5     b     3       x         AUC  0.50
## 6     b     3       x         pR2  0.25
## 7     b     3       y         AUC  0.50
## 8     b     3       y         pR2  0.25</code></pre>
<p>In this form <code>model</code>, <code>testset</code>, and <code>measurement</code> are key columns. <code>depth</code> is still running around as a derived column and the new <code>value</code> column holds the measurements (which could in principle have different types in different rows!).</p>
<p>Data Scientist 3 is not worried about their form causing problems as they know how to convert into Data Scientist 1’s format with an <code>R</code> command:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"tidyr"</span>)

d1_3 &lt;-<span class="st"> </span>d3 %&gt;%
<span class="st">  </span><span class="kw"><a href="http://www.rdocumentation.org/packages/tidyr/topics/spread">spread</a></span>(<span class="st">'measurement'</span>, <span class="st">'value'</span>) %&gt;%
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/select.html">select</a></span>(model, depth, testset, AUC, pR2) %&gt;%<span class="st">  </span><span class="co"># to guarantee column order</span>
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/arrange.html">arrange</a></span>(model, testset)  <span class="co"># to guarantee row order</span>
<span class="kw">print</span>(d1_3)</code></pre></div>
<pre><code>## # A tibble: 4 x 5
##   model depth testset   AUC   pR2
##   &lt;chr&gt; &lt;dbl&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     a     5       x   0.4  0.20
## 2     a     5       y   0.6  0.30
## 3     b     3       x   0.5  0.25
## 4     b     3       y   0.5  0.25</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">all.equal</span>(d1, d1_3)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>You can read a bit on <code><a href="http://www.rdocumentation.org/packages/tidyr/topics/spread">spread()</a></code> <a href="http://r4ds.had.co.nz/tidy-data.html#spreading-and-gathering">here</a>.</p>
<p>We will use the term <code><a href="../reference/moveValuesToColumns.html">moveValuesToColumns()</a></code> for this operation later. The <code><a href="http://www.rdocumentation.org/packages/tidyr/topics/spread">spread()</a></code> will be replaced with the following.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw"><a href="../reference/moveValuesToColumns.html">moveValuesToColumns</a></span>(<span class="dt">data =</span> d3,
                      <span class="dt">columnToTakeKeysFrom =</span> <span class="st">'measurement'</span>,
                      <span class="dt">columnToTakeValuesFrom =</span> <span class="st">'value'</span>,
                      <span class="dt">rowKeyColumns =</span> <span class="kw">c</span>(<span class="st">'model'</span>, <span class="st">'testset'</span>))</code></pre></div>
<p>The above operation is a bit exotic and it (and its inverse) already go under number of different names:</p>
<ul>
<li>
<code>pivot</code> / un-pivot (Microsoft Excel)</li>
<li>
<code>pivot</code> / anti-pivot (databases)</li>
<li>
<code>crosstab</code> / un-crosstab (databases)</li>
<li>
<code>unstack</code> / <code>stack</code> (<code>R</code>)</li>
<li>
<code>cast</code> / <code>melt</code> (<code>reshape</code>, <code>reshape2</code>)</li>
<li>
<code>spread</code> / <code>gather</code> (<code>tidyr</code>)</li>
<li>“widen” / “narrow” (colloquial)</li>
<li>
<code><a href="../reference/moveValuesToColumns.html">moveValuesToColumns()</a></code> and <code><a href="../reference/moveValuesToRows.html">moveValuesToRows()</a></code> (this writeup)</li>
</ul>
<p>And we are certainly neglecting other namings of the concept. We find none of these particularly evocative (though <a href="https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf">cheatsheets help</a>), so one purpose of this note will be to teach these concepts in terms of the deliberately verbose ad-hoc terms: <code><a href="../reference/moveValuesToColumns.html">moveValuesToColumns()</a></code> and <code><a href="../reference/moveValuesToRows.html">moveValuesToRows()</a></code>.</p>
<p>Note: often the data re-arrangement operation is only exposed as part of a larger aggregating or tabulating operation. Also <code><a href="../reference/moveValuesToColumns.html">moveValuesToColumns()</a></code> is considered the harder transform direction (as it has to group rows to work), so it is often supplied in packages, whereas analysts often use ad-hoc methods for the simpler <code><a href="../reference/moveValuesToRows.html">moveValuesToRows()</a></code> operation (to be defined next).</p>
</div>
<div id="data-scientist-4" class="section level4">
<h4 class="hasAnchor">
<a href="#data-scientist-4" class="anchor"></a>Data Scientist 4</h4>
<div class="figure">
<img src="BA.png">
</div>
<p>Data Scientist 4 picks a form that makes models unique keys, and records the results as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d4 &lt;-<span class="st"> </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/reexports.html">tribble</a></span>(
  ~model, ~depth, ~x_AUC, ~x_pR2, ~y_AUC, ~y_pR2,
  <span class="st">'a'</span>,    <span class="dv">5</span>,      <span class="fl">0.4</span>,    <span class="fl">0.2</span>,   <span class="fl">0.6</span>,    <span class="fl">0.3</span>,
  <span class="st">'b'</span>,    <span class="dv">3</span>,      <span class="fl">0.5</span>,    <span class="fl">0.25</span>,  <span class="fl">0.5</span>,    <span class="fl">0.25</span>
)

<span class="kw">print</span>(d4)</code></pre></div>
<pre><code>## # A tibble: 2 x 6
##   model depth x_AUC x_pR2 y_AUC y_pR2
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     a     5   0.4  0.20   0.6  0.30
## 2     b     3   0.5  0.25   0.5  0.25</code></pre>
<p>This is not a problem as it is possible to convert to Data Scientist 3’s format.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d3_4 &lt;-<span class="st"> </span>d4 %&gt;%
<span class="st">  </span><span class="kw"><a href="http://www.rdocumentation.org/packages/tidyr/topics/gather">gather</a></span>(<span class="st">'meas'</span>, <span class="st">'value'</span>, x_AUC, y_AUC, x_pR2, y_pR2) %&gt;%
<span class="st">  </span><span class="kw"><a href="http://www.rdocumentation.org/packages/tidyr/topics/separate">separate</a></span>(meas, <span class="kw">c</span>(<span class="st">'testset'</span>, <span class="st">'measurement'</span>)) %&gt;%
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/select.html">select</a></span>(model, depth, testset, measurement, value) %&gt;%
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/arrange.html">arrange</a></span>(model, testset, measurement)
<span class="kw">print</span>(d3_4)</code></pre></div>
<pre><code>## # A tibble: 8 x 5
##   model depth testset measurement value
##   &lt;chr&gt; &lt;dbl&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;dbl&gt;
## 1     a     5       x         AUC  0.40
## 2     a     5       x         pR2  0.20
## 3     a     5       y         AUC  0.60
## 4     a     5       y         pR2  0.30
## 5     b     3       x         AUC  0.50
## 6     b     3       x         pR2  0.25
## 7     b     3       y         AUC  0.50
## 8     b     3       y         pR2  0.25</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">all.equal</span>(d3, d3_4)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>We will replace the <code>gather</code> operation with <code><a href="../reference/moveValuesToRows.html">moveValuesToRows()</a></code> and the call will look like the following.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> <span class="kw"><a href="../reference/moveValuesToRows.html">moveValuesToRows</a></span>(<span class="dt">data =</span> d4,
                  <span class="dt">nameForNewKeyColumn =</span> <span class="st">'meas'</span>, 
                  <span class="dt">nameForNewValueColumn =</span> <span class="st">'value'</span>, 
                  <span class="dt">columnsToTakeFrom =</span> <span class="kw">c</span>(<span class="st">'x_AUC'</span>, <span class="st">'y_AUC'</span>, <span class="st">'x_pR2'</span>, <span class="st">'y_pR2'</span>))</code></pre></div>
<p><code><a href="../reference/moveValuesToRows.html">moveValuesToRows()</a></code> is (under some restrictions) an inverse of <code><a href="../reference/moveValuesToColumns.html">moveValuesToColumns()</a></code>.</p>
<div class="figure">
<img src="gather_spread.png">
</div>
<p>Although we implement <code><a href="../reference/moveValuesToRows.html">moveValuesToRows()</a></code> and <code>moveValuesToColums()</code> as thin wrappers of <code>tidyr</code>’s <code>gather</code> and <code>spread</code>, we find the more verbose naming (and calling interface) more intuitive. So we encourage you to think directly in terms of <code><a href="../reference/moveValuesToRows.html">moveValuesToRows()</a></code> as moving values to different rows (in the same column), and <code>moveValuesToColums()</code> as moving values to different columns (in the same row). It will usually be apparent from your problem which of these operations you want to use.</p>
</div>
</div>
<div id="the-theory-of-coordinatized-data" class="section level2">
<h2 class="hasAnchor">
<a href="#the-theory-of-coordinatized-data" class="anchor"></a>The Theory of Coordinatized Data</h2>
<p>When you are working with transformations you look for invariants to keep your bearings. All of the above data share an invariant property we call being <em>coordinatized</em> data. In this case the invariant is so strong that one can think of all of the above examples as being equivalent, and the row/column transformations as merely changes of frame of reference.</p>
<p>Let’s define <em>coordinatized data</em> by working with our examples. In all the above examples a value carrying (or payload) cell or entry can be uniquely named as follows:</p>
<pre><code>  c(Table=tableName, (KeyColumn=KeyValue)*, ValueColumn=ValueColumnName)</code></pre>
<p>The above notations are the coordinates of the data item (hence “coordinatized data”).</p>
<p>For instance: the <code>AUC</code> of 0.6 is in a cell that is named as follows for each of our scientists as:</p>
<ul>
<li>Data Scientist 1: <code>c(Table='d1', model='a', testset='y', ValueColumn='AUC')</code>
</li>
<li>Data Scientist 2: <code>c(Table='d2', model='a', testset='y', ValueColumn='AUC')</code>
</li>
<li>Data Scientist 3: <code>c(Table='d3', model='a', testset='y', measurement='AUC', ValueColumn='value')</code>
</li>
<li>Data Scientist 4: <code>c(Table='d4', model='a', ValueColumn= paste('y', 'AUC', sep= '_'))</code>
</li>
</ul>
<p>From our point of view these keys all name the same data item. The fact that we are interpreting one position as a table name and another as a column name is just convention. We can even write <code>R</code> code that uses these keys on all our scientists’ data without performing any reformatting:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># take a map from names to scalar conditions and return a value.</span>
<span class="co"># inefficient method; notional only</span>
lookup &lt;-<span class="st"> </span>function(key) {
  table &lt;-<span class="st"> </span><span class="kw">get</span>(key[[<span class="st">'Table'</span>]])
  col &lt;-<span class="st"> </span>key[[<span class="st">'ValueColumn'</span>]]
  conditions &lt;-<span class="st"> </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/setops.html">setdiff</a></span>(<span class="kw">names</span>(key), 
                        <span class="kw">c</span>(<span class="st">'Table'</span>, <span class="st">'ValueColumn'</span>))
  for(ci in conditions) {
    table &lt;-<span class="st"> </span>table[table[[ci]]==key[[ci]], ,
                   drop=<span class="st"> </span><span class="ot">FALSE</span>]
  }
  table[[col]][[<span class="dv">1</span>]]
}

k1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">Table=</span><span class="st">'d1'</span>, <span class="dt">model=</span><span class="st">'a'</span>, <span class="dt">testset=</span><span class="st">'y'</span>, 
        <span class="dt">ValueColumn=</span><span class="st">'AUC'</span>)
k2 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">Table=</span><span class="st">'d2'</span>, <span class="dt">model=</span><span class="st">'a'</span>, <span class="dt">testset=</span><span class="st">'y'</span>, 
        <span class="dt">ValueColumn=</span><span class="st">'AUC'</span>)
k3 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dt">Table=</span><span class="st">'d3'</span>, <span class="dt">model=</span><span class="st">'a'</span>, <span class="dt">testset=</span><span class="st">'y'</span>, 
        <span class="dt">measurement=</span><span class="st">'AUC'</span>, <span class="dt">ValueColumn=</span><span class="st">'value'</span>)
k4 =<span class="st"> </span><span class="kw">c</span>(<span class="dt">Table=</span><span class="st">'d4'</span>, <span class="dt">model=</span><span class="st">'a'</span>, 
       <span class="dt">ValueColumn=</span> <span class="kw">paste</span>(<span class="st">'y'</span>, <span class="st">'AUC'</span>, <span class="dt">sep=</span> <span class="st">'_'</span>))

<span class="kw">print</span>(<span class="kw">lookup</span>(k1))</code></pre></div>
<pre><code>## [1] 0.6</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">lookup</span>(k2))</code></pre></div>
<pre><code>## [1] 0.6</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">lookup</span>(k3))</code></pre></div>
<pre><code>## [1] 0.6</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">lookup</span>(k4))</code></pre></div>
<pre><code>## [1] 0.6</code></pre>
<p>The <code>lookup()</code> procedure was able to treat all these keys and key positions uniformly. This illustrates that what is in tables versus what is in rows versus what is in columns is just an implementation detail. Once we understand that all of these data scientists recorded the same data we should not be surprised we can convert between representations.</p>
<p>The thing to remember: coordinatized data is in cells, and every cell has unique coordinates. We are going to use this invariant as our enforced <a href="https://en.wikipedia.org/wiki/Precondition">precondition</a> before any data transform, which will guarantee our data meets this invariant as a postcondition. I.e., if we restrict ourselves to coordinatized data and exclude wild data, the operations <code><a href="../reference/moveValuesToColumns.html">moveValuesToColumns()</a></code> and <code><a href="../reference/moveValuesToRows.html">moveValuesToRows()</a></code> become well-behaved and much easier to comprehend. In particular, <em>they are invertible</em>. (In math terms, the operators <code><a href="../reference/moveValuesToColumns.html">moveValuesToColumns()</a></code> and <code><a href="../reference/moveValuesToRows.html">moveValuesToRows()</a></code> form a <a href="https://en.wikipedia.org/wiki/Groupoid">groupoid</a> acting on coordinatized data.)</p>
<div class="figure">
<img src="15puzzleGroupoid.png">
</div>
<p><a href="http://www.neverendingbooks.org/the-15-puzzle-groupoid-1">The 15 puzzle: another groupoid</a></p>
<p>By “wild” data we mean data where cells don’t have unique <code>lookup()</code> addresses. This often happens in data that has repeated measurements. Wild data is simply tamed by adding additional keying columns (such as an arbitrary experiment repetition number). Hygienic data collection practice nearly always produces coordinatized data, or at least data that is easy to coordinatize. Our position is that your data should always be coordinatized; if it’s not, you shouldn’t be working with it yet.</p>
</div>
<div id="rows-and-columns" class="section level2">
<h2 class="hasAnchor">
<a href="#rows-and-columns" class="anchor"></a>Rows and Columns</h2>
<p>Many students are initially surprised that row/column conversions are considered “easy.” Thus, it is worth taking a little time to review moving data between rows and columns.</p>
<div id="moving-from-columns-to-rows-thinifying-data" class="section level3">
<h3 class="hasAnchor">
<a href="#moving-from-columns-to-rows-thinifying-data" class="anchor"></a>Moving From Columns to Rows (“Thinifying data”)</h3>
<div class="figure">
<img src="Gather.png">
</div>
<p>Moving data from columns to rows (i.e., from Scientist 1 to Scientist 3) is easy to demonstrate and explain.</p>
<p>The only thing hard about this operation is remembering the name of the operation (“<code><a href="http://www.rdocumentation.org/packages/tidyr/topics/gather">gather()</a></code>”) and the arguments. We can remove this inessential difficulty by bringing in a verbose wrapper function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">"cdata"</span>)</code></pre></div>
<p>In this notation moving from Data Scientist 1’s records to Data Scientist 3’s looks like the following.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d3from1 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/moveValuesToRows.html">moveValuesToRows</a></span>(<span class="dt">data=</span>d1,
                            <span class="dt">nameForNewKeyColumn=</span> <span class="st">'measurement'</span>,
                            <span class="dt">nameForNewValueColumn=</span> <span class="st">'value'</span>,
                            <span class="dt">columnsToTakeFrom =</span> <span class="kw">c</span>(<span class="st">'AUC'</span>, <span class="st">'pR2'</span>)) %&gt;%
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/select.html">select</a></span>(model, depth, testset, measurement, value) %&gt;%
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/arrange.html">arrange</a></span>(model, testset, measurement)
<span class="kw">print</span>(d3from1)</code></pre></div>
<pre><code>## # A tibble: 8 x 5
##   model depth testset measurement value
##   &lt;chr&gt; &lt;dbl&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;dbl&gt;
## 1     a     5       x         AUC  0.40
## 2     a     5       x         pR2  0.20
## 3     a     5       y         AUC  0.60
## 4     a     5       y         pR2  0.30
## 5     b     3       x         AUC  0.50
## 6     b     3       x         pR2  0.25
## 7     b     3       y         AUC  0.50
## 8     b     3       y         pR2  0.25</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">all.equal</span>(d3, d3from1)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>In a <code><a href="../reference/moveValuesToRows.html">moveValuesToRows()</a></code> operation each row of the data frame is torn up and used to make many rows. Each of the columns we specify that we want measurements from gives us a new row from each of the original data rows.</p>
<p>The pattern is more obvious if we process any rows of <code>d1</code> independently:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">row &lt;-<span class="st"> </span>d1[<span class="dv">3</span>,]
<span class="kw">print</span>(row)</code></pre></div>
<pre><code>## # A tibble: 1 x 5
##   model depth testset   AUC   pR2
##   &lt;chr&gt; &lt;dbl&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     b     3       x   0.5  0.25</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/moveValuesToRows.html">moveValuesToRows</a></span>(<span class="dt">data=</span>row,
                 <span class="dt">nameForNewKeyColumn=</span> <span class="st">'measurement'</span>,
                 <span class="dt">nameForNewValueColumn=</span> <span class="st">'value'</span>,
                 <span class="dt">columnsToTakeFrom =</span> <span class="kw">c</span>(<span class="st">'AUC'</span>, <span class="st">'pR2'</span>)) %&gt;%
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/select.html">select</a></span>(model, depth, testset, measurement, value) %&gt;%
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/arrange.html">arrange</a></span>(model, testset, measurement)</code></pre></div>
<pre><code>## # A tibble: 2 x 5
##   model depth testset measurement value
##   &lt;chr&gt; &lt;dbl&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;dbl&gt;
## 1     b     3       x         AUC  0.50
## 2     b     3       x         pR2  0.25</code></pre>
</div>
<div id="moving-from-rows-to-columns-widening-data" class="section level3">
<h3 class="hasAnchor">
<a href="#moving-from-rows-to-columns-widening-data" class="anchor"></a>Moving From Rows to Columns (“Widening data”)</h3>
<p>Moving data from rows to columns (i.e., from Scientist 3 to Scientist 1) is a bit harder to explain, and usually not explained well.</p>
<p>In moving from rows to columns we group a set of rows that go together (match on keys) and then combine them into one row by adding additional columns.</p>
<div class="figure">
<img src="Spread.png">
</div>
<p>Note: to move data from rows to columns <em>we must know which set of rows go together</em>. That means some set of columns is working as keys, even though this is not emphasized in the <code><a href="http://www.rdocumentation.org/packages/tidyr/topics/spread">spread()</a></code> calling interface or explanations. For invertible data transforms, we want a set of columns (<code>rowKeyColumns</code>) that define a composite key that uniquely identifies each row of the result. For this to be true, the <code>rowKeyColumns</code> plus the column we are taking value keys from must uniquely identify each row of the input.</p>
<p>To make things easier to understand and remember, we introduce another wrapping function: <code><a href="../reference/moveValuesToColumns.html">moveValuesToColumns()</a></code>.</p>
<p>This lets us rework the example of moving from Data Scientist 3’s format to Data Scientist 1’s:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d1from3 &lt;-<span class="st"> </span><span class="kw"><a href="../reference/moveValuesToColumns.html">moveValuesToColumns</a></span>(<span class="dt">data=</span> d3,
                    <span class="dt">columnToTakeKeysFrom=</span> <span class="st">'measurement'</span>,
                    <span class="dt">columnToTakeValuesFrom=</span> <span class="st">'value'</span>,
                    <span class="dt">rowKeyColumns=</span> <span class="kw">c</span>(<span class="st">'model'</span>, <span class="st">'testset'</span>)) %&gt;%
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/select.html">select</a></span>(model, depth, testset, AUC, pR2) %&gt;%
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/arrange.html">arrange</a></span>(model, testset)
<span class="kw">print</span>(d1from3)</code></pre></div>
<pre><code>## # A tibble: 4 x 5
##   model depth testset   AUC   pR2
##   &lt;chr&gt; &lt;dbl&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     a     5       x   0.4  0.20
## 2     a     5       y   0.6  0.30
## 3     b     3       x   0.5  0.25
## 4     b     3       y   0.5  0.25</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">all.equal</span>(d1, d1from3)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>If the structure of our data doesn’t match our expected keying we can have problems. We emphasize that these problems arise from trying to work with non-coordinatized data, and not from the transforms themselves.</p>
<div id="too-little-keying" class="section level5">
<h5 class="hasAnchor">
<a href="#too-little-keying" class="anchor"></a>Too little keying</h5>
<p>If our keys don’t contain enough information to match rows together we can have a problem. Suppose our <code>testset</code> record was damaged or not present and look how a direct call to <code>spread</code> works:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d3damaged &lt;-<span class="st"> </span>d3
d3damaged$testset &lt;-<span class="st"> 'z'</span>
<span class="kw">print</span>(d3damaged)</code></pre></div>
<pre><code>## # A tibble: 8 x 5
##   model depth testset measurement value
##   &lt;chr&gt; &lt;dbl&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;dbl&gt;
## 1     a     5       z         AUC  0.40
## 2     a     5       z         pR2  0.20
## 3     a     5       z         AUC  0.60
## 4     a     5       z         pR2  0.30
## 5     b     3       z         AUC  0.50
## 6     b     3       z         pR2  0.25
## 7     b     3       z         AUC  0.50
## 8     b     3       z         pR2  0.25</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="http://www.rdocumentation.org/packages/tidyr/topics/spread">spread</a></span>(d3damaged, <span class="st">'measurement'</span>, <span class="st">'value'</span>)</code></pre></div>
<pre><code>## Error: Duplicate identifiers for rows (1, 3), (5, 7), (2, 4), (6, 8)</code></pre>
<p>This happens because the precondition is not met: the columns <code>(model, testset, measurement)</code> don’t uniquely represent each row of the input. Catching the error is good, and we emphasize that in our wrapper.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/moveValuesToColumns.html">moveValuesToColumns</a></span>(<span class="dt">data=</span> d3damaged,
                    <span class="dt">columnToTakeKeysFrom=</span> <span class="st">'measurement'</span>,
                    <span class="dt">columnToTakeValuesFrom=</span> <span class="st">'value'</span>,
                    <span class="dt">rowKeyColumns=</span> <span class="kw">c</span>(<span class="st">'model'</span>, <span class="st">'testset'</span>))</code></pre></div>
<pre><code>## Error in moveValuesToColumns(data = d3damaged, columnToTakeKeysFrom = "measurement", : 
##  moveValeusToColumns: specified
##  rowKeyColumns plus columnToTakeKeysFrom
##  isn't unique across rows</code></pre>
<p>The above issue is often fixed by adding additional columns (such as measurement number or time of measurement).</p>
</div>
<div id="too-much-keying" class="section level5">
<h5 class="hasAnchor">
<a href="#too-much-keying" class="anchor"></a>Too much keying</h5>
<p>Columns can also contain too fine a key structure. For example, suppose our data was damaged and <code>depth</code> is no longer a function of the model id, but contains extra detail. In this case a direct call to <code>spread</code> produces a way too large result because the extra detail prevents it from matching rows.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d3damaged &lt;-<span class="st"> </span>d3
d3damaged$depth &lt;-<span class="st"> </span><span class="kw">seq_len</span>(<span class="kw">nrow</span>(d3damaged))
<span class="kw">print</span>(d3damaged)</code></pre></div>
<pre><code>## # A tibble: 8 x 5
##   model depth testset measurement value
##   &lt;chr&gt; &lt;int&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;dbl&gt;
## 1     a     1       x         AUC  0.40
## 2     a     2       x         pR2  0.20
## 3     a     3       y         AUC  0.60
## 4     a     4       y         pR2  0.30
## 5     b     5       x         AUC  0.50
## 6     b     6       x         pR2  0.25
## 7     b     7       y         AUC  0.50
## 8     b     8       y         pR2  0.25</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="http://www.rdocumentation.org/packages/tidyr/topics/spread">spread</a></span>(d3damaged, <span class="st">'measurement'</span>, <span class="st">'value'</span>) </code></pre></div>
<pre><code>## # A tibble: 8 x 5
##   model depth testset   AUC   pR2
## * &lt;chr&gt; &lt;int&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     a     1       x   0.4    NA
## 2     a     2       x    NA  0.20
## 3     a     3       y   0.6    NA
## 4     a     4       y    NA  0.30
## 5     b     5       x   0.5    NA
## 6     b     6       x    NA  0.25
## 7     b     7       y   0.5    NA
## 8     b     8       y    NA  0.25</code></pre>
<p>The frame <code>d3damaged</code> does not match the user’s probable intent: that the columns <code>(model, testset)</code> should uniquely specify row groups, or in other words, they should uniquely identify each row of the result.</p>
<p>In the above case we feel it is good to allow the user to declare intent (hence the extra <code>rowKeyColumns</code> argument) and throw an exception if the data is not structured how the user expects (instead of allowing this data to possibly ruin a longer analysis in some unnoticed manner).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/moveValuesToColumns.html">moveValuesToColumns</a></span>(<span class="dt">data=</span> d3damaged,
                    <span class="dt">columnToTakeKeysFrom=</span> <span class="st">'measurement'</span>,
                    <span class="dt">columnToTakeValuesFrom=</span> <span class="st">'value'</span>,
                    <span class="dt">rowKeyColumns=</span> <span class="kw">c</span>(<span class="st">'model'</span>, <span class="st">'testset'</span>))</code></pre></div>
<pre><code>## Error in moveValuesToColumns(data = d3damaged, columnToTakeKeysFrom = "measurement", : 
##  some columns not in
##  c(rowKeyColumns, columnToTakeKeysFrom, columnToTakeValuesFrom)
##  are splitting up row groups</code></pre>
<p>The above issue is usually fixed by one of two solutions (which one is appropriate depends on the situation):</p>
<ol style="list-style-type: decimal">
<li>Stricter control (via <code><a href="http://dplyr.tidyverse.org/reference/select.html">dplyr::select()</a></code>) of which columns are in the analysis. In our example, we would <code>select</code> all the columns of <code>d3damaged</code> except <code>depth</code>.</li>
<li>Aggregating or summing out the problematic columns. For example if the problematic column in our example were <code>runtime</code>, which could legitimately vary for the same model and dataset, we could use <code>dplyr::group_by/summarize</code> to create a data frame with columns <code>(model, testset, mean_runtime, measurement, value)</code>, so that <code>(model, testset)</code> does uniquely specify row groups.</li>
</ol>
</div>
</div>
</div>
<div id="conclusion" class="section level2">
<h2 class="hasAnchor">
<a href="#conclusion" class="anchor"></a>Conclusion</h2>
<p>The concept to remember is: organize your records so data cells have unique consistent abstract coordinates. For coordinatized data the actual arrangement of data into tables, rows, and columns is an implementation detail or optimization that does not significantly change what the data means.</p>
<p>For coordinatized data different layouts of rows and columns are demonstrably equivalent. We document and maintain this equivalence by asking the analyst to describe their presumed keying structure to our methods, which then use this documentation to infer intent and check preconditions on the transforms.</p>
<p>It pays to think fluidly in terms of coordinatized data and delay any format conversions until you actually need them. You will eventually need transforms as most data processing steps have a preferred format. For example, machine learning training usually requires a denormalized form.</p>
<p>We feel the methods <code><a href="../reference/moveValuesToRows.html">moveValuesToRows()</a></code> and <code><a href="../reference/moveValuesToColumns.html">moveValuesToColumns()</a></code> are easier to learn and remember than abstract terms such as “stack/unstack”, “melt/cast”, or “gather/spread” and thus are a good way to teach. Perhaps they are even a good way to document (and confirm) your intent in your own projects.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#example">Example</a></li>
      <li><a href="#the-theory-of-coordinatized-data">The Theory of Coordinatized Data</a></li>
      <li><a href="#rows-and-columns">Rows and Columns</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by John Mount, Nina Zumel.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
