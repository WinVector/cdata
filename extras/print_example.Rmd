---
title: "cdata: the essentials"
author: "Nina Zumel"
date: "3/28/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Our regular Win-Vector blog readers have no doubt seen the tsunami of `cdata` related posts
that John has written over the last couple of weeks. I suspect that a lot of you have been thinking
(but are too polite to say out loud): "That's a lot of words for an idea that's not that deep."

And I (Nina) agree. Data shaping is a bit complicated to talk about, but as an idea it's not that profound---not even the "coordinatized data" part. We originally developed the `cdata` package as a teaching tool, a "training wheels" package that tries to make explicit what is going on, because we found that students often found the calling interface of the `tidyr` functions somewhat terse. I believe that the biggest contributions of `cdata` are:

1) An unambiguous vocabulary to talk about data reshaping

2) The idea that one should draw the data shape you want (even before you begin coding it).

We've talked about the vocabulary before, [in this vignette](https://winvector.github.io/cdata/articles/blocksrecs.html). To "draw" or specify the data shape, `cdata` uses the *control table*. And in an upcoming release, we're adding some new capabilities to make visualizing the transforms even easier.

*A worked example*

In my own work, the data I'm working with generally needs to be in rowrecs before I model it. Good ol' `iris` is an example.

```{r}
data(iris)

iris$iris_id <- seq_len(nrow(iris))

head(iris)

```

Every individual iris measurement is in a single row; I've added an id column to make that clear (and to make
the data transforms invertible). The main reason I would ever need to reshape this into blocks is to plot it with
`ggplot2`: I want to color-code or facet on a variable (say Species). A single `gather()` suffices for that.

However, in some cases, I might want to color code on one variable (Species) and facet on another (flower part -- which isn't even explicitly a variable in the data's current form). Like this:

![](http://www.win-vector.com/blog/wp-content/uploads/2018/10/unnamed-chunk-2-1.png)

This is the data shape that `ggplot()` needs to make the above plot:

![](https://winvector.github.io/cdata/articles/blocks_to_rowrecs.png)

Now a single record is distributed across two rows; it's a block. All the length measurements are in one column and the widths are in another, so we can scatterplot.  We need an additional variable `flower_part` to specify whether we are talking about petals or sepals and to facet the graph accordingly. We need to carry along the `Species` information so we can color-code on it. If we ever want to invert the transformed data, we need to also carry along the `id` column, because that identifies which rows belong to the same record.. Transforming `iris` into this shape can't be done with a single `gather()`, but it can be done with `cdata`. 

The way to "draw" the desired data shape for `cdata` is via the control table.

```{r}
controlTable <- wrapr::qchar_frame(
  "flower_part"  , "Length"    , "Width"     |
    "Petal"      , Petal.Length, Petal.Width |
    "Sepal"      , Sepal.Length, Sepal.Width )

controlTable
```

Note the control table is just a data frame. You can create it with data.frame() or tribble() or whatever constructor you prefer. We use `wrapr::qchar_frame` simply because it draws up pretty. In the code above, the terms in quotes are the names of columns in the existing `iris` frame, and the unquoted terms are the columns to be created (and the new key values to be created) in the new frame.

![](https://winvector.github.io/cdata/articles/rowrecs_to_blocks.png)

To reshape the data, call `rowrecs_to_blocks()`:

```{r}
library(cdata)

# these are the columns we want to carry along from each record
row_keys = c("iris_id", "Species")

iris_aug <- rowrecs_to_blocks(
  iris,
  controlTable,
  columnsToCopy = row_keys)

head(iris_aug)
```



In fact, up until recently, I personally used `gather()` and `spread()` for at least 95% of my data shaping needs, and we intended to use `tidyr` for data shaping in the second edition of [our book](https://www.manning.com/books/practical-data-science-with-r-second-edition), as `tidyr` is a better-known package than `cdata`.

Unfortunately, `gather()` and `spread()` seem to now be demphasized in favor of upcoming new methods, and I don't want our book to be out-of-date before it's even published. And since I don't know when `tidyr` will be stable: `cdata` it is.

But before then, I only used `cdata` for two situations:

* Working with data in remote stores (`tidyr` works only locally)
* Creating graphs where I want to color-code the plot on one variable and facet it on another. Like this one:

![](http://www.win-vector.com/blog/wp-content/uploads/2018/10/unnamed-chunk-2-1.png)



I believe that the biggest contribution of `cdata` is that it gives us an unambiguous vocabulary and tools of thought to talk about data reshaping; and in an upcoming release, `cdata` will also give you  














https://winvector.github.io/cdata/articles/blocksrecs.html
http://www.win-vector.com/blog/2018/10/faceted-graphs-with-cdata-and-ggplot2/

```{r}
library("cdata")

data(iris)

iris$iris_id <- seq_len(nrow(iris))

head(iris)

row_keys = c("iris_id", "Species")

controlTable <- wrapr::qchar_frame(
  flower_part  , Length        , Width         |
    Petal      , "Petal.Length", "Petal.Width" |
    Sepal      , "Sepal.Length", "Sepal.Width" )

knitr::kable(controlTable)

transform_spec <- rowrecs_to_blocks_spec(
  controlTable,
  recordKeys = row_keys)

plot_frame <- iris %.>% transform_spec

head(plot_frame)

print(transform_spec)

tranform_details <- get_transform_details(transform_spec)

knitr::kable(tranform_details$block_record)

knitr::kable(tranform_details$row_record)
```

